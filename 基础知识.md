面试技巧

### umu面试
- react 虚拟dom对比，采取的是对象相同对比是用的标签类型
- css那些隐藏办法 
    - display none
    - visibility hidden 没有点击事件
    - position absolute  offscreen
    - z-index -1
    - opacity 0  有点击事件
- 准备一个前端的难点
- ts
- react新的api
- node事件循环和js事件循环

## 简历
- 系统重构
- 工作内容和成果
- 表格采用canvasRenderer渲染，提高渲染效率，antd虚拟列表存在dom操作问题，导致渲染效率低。


## 面试准备
### 一面
- react 18 hooks原理
- react 18 性能优化
- react fiber 原理
- concurrent mode
- react 18 新特性
    -
- react 错误捕获
    - Error Boundary（componentDidCatch和getDerivedStateFromError）
    - 错误边界只能捕获子组件的错误，不能捕获自身的错误

- react 脚手架创建（vite、create-react-app）
    - vite
        - 基于esbuild打包，打包速度快
        - 支持热更新
    - create-react-app
        - 基于webpack打包，打包速度慢
        - 不支持热更新
- 脚手架 -> jsx -> babel编译（@babel/preset-react）-> jsx-runtime(本质上是创建reactElement)->虚拟dom

ref forwardRef suspense lazy 新特性
- ref forwardRef
    - 转发ref，将ref从父组件传递到子组件
- suspense
    - 异步组件加载，等待组件加载完成后再渲染
    - 可以在组件加载过程中显示loading状态
    - 可以在组件加载失败后显示错误状态
    - 可以在组件加载完成后缓存组件，避免重复加载
- memo
    - 记忆化组件，当组件的props没有变化时，不会重新渲染组件
    - 可以配置一个比较函数，用于比较props是否变化（默认是浅比较）
- useSate
    - 状态管理，用于管理组件的状态
    - 可以配置一个初始状态，返回一个状态值和一个更新状态的函数
    - 可以使用函数式更新，用于更新状态值
    - 可以使用批量更新，用于批量更新状态值
    - 本质调用的是useReducer的语法糖
- useEffect
    - 副作用管理，用于管理组件的副作用
    - 可以配置一个依赖数组，用于指定依赖的状态值
    - 可以返回一个清理函数，用于在组件卸载时清理副作用
- useLayoutEffect
    - 副作用管理，用于管理组件的副作用
    - 可以配置一个依赖数组，用于指定依赖的状态值
    - 可以返回一个清理函数，用于在组件卸载时清理副作用
    - 区别
        - 执行时机不同
            - useEffect是在组件渲染完成后执行
            - useLayoutEffect是在组件渲染完成前执行
        - 阻塞渲染不同
            - useEffect是异步执行的，不会阻塞渲染
            - useLayoutEffect是同步执行的，会阻塞渲染
        - 应用场景不同
            - useEffect适用于异步操作，如网络请求、事件监听等
            - useLayoutEffect适用于同步操作，如操作dom、计算布局等


- useImmer
    - 状态管理，用于管理组件的状态
    - 可以配置一个初始状态，返回一个状态值和一个更新状态的函数
    - 可以使用函数式更新，用于更新状态值
    - 可以使用批量更新，用于批量更新状态值
    - 本质调用的是useReducer的语法糖

- useImperativeHandle
    - 自定义暴露给父组件的实例值
    - 可以配置一个依赖数组，用于指定依赖的状态值
    - 可以返回一个对象，用于暴露给父组件的实例值
    - 可以使用forwardRef将ref转发到子组件
    - 可以使用useImperativeHandle自定义暴露给父组件的实例值
 
 - useTransition
    - 过渡管理，用于管理组件的过渡状态
 - useDeferredValue
    - 延迟值管理，用于管理组件的延迟值
 -   
    - 外部状态管理，用于管理外部状态
 
 - useContext
    - 上下文管理，用于管理全局状态
    - 可以使用createContext创建上下文
    - 可以使用useContext消费上下文
    - 可以使用Provider提供上下文，可以内置theme,setTheme,children
    - 优化点按功能点进行拆分，AppContext、themeContext、useTheme、通过children隔离，缺点就是大对象一改变全局都要rerender

#### redux
- 状态管理，用于管理全局状态
    - 可以使用createStore创建store
    - 可以使用dispatch分发action
    - 可以使用subscribe订阅state变化
    - 可以使用combineReducers合并reducer
    - 可以使用applyMiddleware应用中间件
    - 可以使用compose组合中间件
    - 可以使用bindActionCreators绑定action creator
    - 可以使用@connect连接组件和store
    - 可以使用@selector选择state
    - 可以使用@action创建action
    - 可以使用@reducer创建reducer
    - 可以使用@middleware创建中间件
    - 可以使用@store创建store
    - 可以使用@combineReducers合并reducer
- 
- 细粒度更新 useSelector







### 二面
- 优化项目介绍和钩子(Hook)的使用

### HR面
- 范围 18-20

## 场景题
- 流程化 sop
    - 交代背景
    - 调研方案
    - 方案落地
    - 反思，追求更优解答

### 举例
当被面试官问到1000w行表格如何进行渲染，如多维表格、飞书表格、钉钉表格、在线表追求大数据量
- 数据量足够大，生产数据查询，需要在前端展示大量数据防卡顿，通过那些方案实现
- 作为负责人，调研了的方案
    - dom
    - 虚拟表格
    - canvas table
    - 可视区绘制算法优化
    - canvas结合webassembly技术实现（skia+webassembly）
- 结论封装的画布表格引擎，解决了上述问题，并且能够实现1000w数据加载流畅交互
- 在解决这个问题中还遇到了那么问题，我是怎么解决的 

## AI
### MCP
 - 建立通信->工具发现->工具调用
 - 创建过程 创建npx @modelcontextprotocol/sdk 检查 npx @modelcontextprotocol/inspector（注意调试不能用console.log要用error不然会污染环境）


